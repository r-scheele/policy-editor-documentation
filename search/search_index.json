{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This project aims to abstract the technical details of writing REGO and provide a simple interface to write policies for your application in a Github/Gitlab repository. By transforming the familiar JSON format to REGO, the developer can focus on writing the policy and not on the technical details of REGO. Example request and response to the policy editor. As an example, the API transforms the following JSON policy into REGO rules: { \"example\" : { \"name\" : \"Example\" , \"repo_url\" : \"https://github.com/geobeyond/test-rego\" , \"repo_id\" : 12345 , \"rules\" : [ [ { \"command\" : \"allow_if_object_in_database\" , \"properties\" : { \"datasource_name\" : \"usergroups\" , \"datasource_variables\" : [ \"name\" , \"groupname\" ], }, }, { \"command\" : \"input_prop_in\" , \"properties\" : { \"input_property\" : \"company\" , \"datasource_name\" : \"items\" , \"datasource_loop_variable\" : \"name\" , }, }, { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_method\" , \"value\" : \"GET\" , }, }, ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"company\" , \"value\" : \"geobeyond\" , }, }, ], [ { \"command\" : \"allow_full_access\" , \"properties\" : { \"input_property\" : \"groupname\" , \"value\" : \"EDITOR_ATAC\" , }, }, ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/*\" , \"exceptional_value\" : \"obs\" , }, } ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}/*\" , }, } ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/*\" , }, } ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections\" , }, }, ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}\" , }, } ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}/*\" , \"exceptional_value\" : \"obs\" , }, } ], ], } } result: package httpapi.authz import input default allow = false allow { {\"name\": input.name,\"groupname\": input.groupname} = data.usergroups[_] input.company = data.items[_].company input.request_method = \"GET\" } allow { input.company = \"geobeyond\" } allow { input.groupname = \"EDITOR_ATAC\" } allow { input.request_path[0] = \"v1\" input.request_path[1] = \"collections\" input.request_path[1] != \"obs\" } allow { some username input.request_path = [\"user\", username] input.preferred_username = username } allow { input.request_path[0] = \"v1\" input.request_path[1] = \"collections\" } allow { input.request_path = [\"v1\"] } allow { some username input.preferred_username = username input.request_path[0] = \"v1\" input.request_path[1] = \"collections\" input.request_path[2] != \"obs\" }","title":"Introduction"},{"location":"#introduction","text":"This project aims to abstract the technical details of writing REGO and provide a simple interface to write policies for your application in a Github/Gitlab repository. By transforming the familiar JSON format to REGO, the developer can focus on writing the policy and not on the technical details of REGO.","title":"Introduction"},{"location":"#example-request-and-response-to-the-policy-editor","text":"As an example, the API transforms the following JSON policy into REGO rules: { \"example\" : { \"name\" : \"Example\" , \"repo_url\" : \"https://github.com/geobeyond/test-rego\" , \"repo_id\" : 12345 , \"rules\" : [ [ { \"command\" : \"allow_if_object_in_database\" , \"properties\" : { \"datasource_name\" : \"usergroups\" , \"datasource_variables\" : [ \"name\" , \"groupname\" ], }, }, { \"command\" : \"input_prop_in\" , \"properties\" : { \"input_property\" : \"company\" , \"datasource_name\" : \"items\" , \"datasource_loop_variable\" : \"name\" , }, }, { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_method\" , \"value\" : \"GET\" , }, }, ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"company\" , \"value\" : \"geobeyond\" , }, }, ], [ { \"command\" : \"allow_full_access\" , \"properties\" : { \"input_property\" : \"groupname\" , \"value\" : \"EDITOR_ATAC\" , }, }, ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/*\" , \"exceptional_value\" : \"obs\" , }, } ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}/*\" , }, } ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/*\" , }, } ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections\" , }, }, ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}\" , }, } ], [ { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}/*\" , \"exceptional_value\" : \"obs\" , }, } ], ], } } result: package httpapi.authz import input default allow = false allow { {\"name\": input.name,\"groupname\": input.groupname} = data.usergroups[_] input.company = data.items[_].company input.request_method = \"GET\" } allow { input.company = \"geobeyond\" } allow { input.groupname = \"EDITOR_ATAC\" } allow { input.request_path[0] = \"v1\" input.request_path[1] = \"collections\" input.request_path[1] != \"obs\" } allow { some username input.request_path = [\"user\", username] input.preferred_username = username } allow { input.request_path[0] = \"v1\" input.request_path[1] = \"collections\" } allow { input.request_path = [\"v1\"] } allow { some username input.preferred_username = username input.request_path[0] = \"v1\" input.request_path[1] = \"collections\" input.request_path[2] != \"obs\" }","title":"Example request and response to the policy editor."},{"location":"api/","text":"Rest API The application is a secured REST API, protected with an access token generated from either gitlab or github, depending on the repository you are using. Which means that you need to be authenticated to with Gitlab if you are using a Gitlab repository, and with Github if you are using a Github repository. Using the API is pretty straightforward without a front-end, you just need to send a request to the API endpoint, with the access token in the header. The access token is generated from the Gitlab or Github account you are using to access the repository. If you prefer to access the API using the swagger interface, you need to paste the access token in the top right corner of the swagger interface(see image below). Authentication GET /gitlab/token - Get a Gitlab access token GET /github/token - Get a Github access token These endpoints are only needed if your application has a front-end. They will redirect you to the Gitlab or Github authentication page, and then redirect you back to the application with a valid access token. Policy CRUD Operations Please visit the /redoc endpoint to see the API documentation. Repository Management Front-end use case This section contains the endpoints for managing the repositories used by the application. Depending on the sign in method used by the user, repositories from the token provider can be accessed as a list. GET /user/repo/github GET /user/repo/gitlab This endpoint is used to select which repo the user wants to use. The response will be a list of all the repositories that the user has access to. Backend use case If the API is used directly, the repository to use for writing the policy is supplied as a url, in the request body For Gitlab provider, identifying the repository for writing the policy requires both the url and the repo id. The repo is retrieved from the response body of the GET request to the Gitlab API /user/repo/gitlab . { \"repo_url\" : \"https://gitlab.com/youngestdev1/policies/opal-server\" , \"repo_id\" : 39020791 , ... } Database Operations GET /data This endpoint retrieves the groupnames stored as part of the usergroups needed in the rego policy creation, it is used to accurately populate the dropdown menu in the frontend. The response will be a list of all the groupnames that have been stored in the database. Example response body: { \"geostore.usergroup\" : [ \"EDITOR_DPAU\" , \"EDITOR_CPQ\" , \"VIEWER\" , \"everyone\" , \"EDITOR_ATAC\" , \"TestGeocity\" , \"EDITOR_AMBIENTE\" , \"GEOCITY_ADMINS\" , \"EDITOR_SIZA\" , \"ROLE_SYS_GWCS\" , \"EDITOR_SITPAU\" , \"EDITOR_DBGT\" , \"ctr-AltimetriaLineeCTRN-VIEW\" , \"ctr-AltimetriaLineeCTRN-EDIT\" , \"EDITOR_NIC\" , \"ambiente-AsparmRaccoltaFarmaci-EDIT\" , \"EDITOR_URBANISTICA\" , \"EDITOR_CITTA_PUBBLICA\" , \"EDITOR_VINCOLI\" , \"EDITOR_COMPLETO\" ] }","title":"API Endpoints"},{"location":"api/#rest-api","text":"The application is a secured REST API, protected with an access token generated from either gitlab or github, depending on the repository you are using. Which means that you need to be authenticated to with Gitlab if you are using a Gitlab repository, and with Github if you are using a Github repository. Using the API is pretty straightforward without a front-end, you just need to send a request to the API endpoint, with the access token in the header. The access token is generated from the Gitlab or Github account you are using to access the repository. If you prefer to access the API using the swagger interface, you need to paste the access token in the top right corner of the swagger interface(see image below).","title":"Rest API"},{"location":"api/#authentication","text":"GET /gitlab/token - Get a Gitlab access token GET /github/token - Get a Github access token These endpoints are only needed if your application has a front-end. They will redirect you to the Gitlab or Github authentication page, and then redirect you back to the application with a valid access token.","title":"Authentication"},{"location":"api/#policy-crud-operations","text":"Please visit the /redoc endpoint to see the API documentation.","title":"Policy CRUD Operations"},{"location":"api/#repository-management","text":"","title":"Repository Management"},{"location":"api/#front-end-use-case","text":"This section contains the endpoints for managing the repositories used by the application. Depending on the sign in method used by the user, repositories from the token provider can be accessed as a list. GET /user/repo/github GET /user/repo/gitlab This endpoint is used to select which repo the user wants to use. The response will be a list of all the repositories that the user has access to.","title":"Front-end use case"},{"location":"api/#backend-use-case","text":"If the API is used directly, the repository to use for writing the policy is supplied as a url, in the request body For Gitlab provider, identifying the repository for writing the policy requires both the url and the repo id. The repo is retrieved from the response body of the GET request to the Gitlab API /user/repo/gitlab . { \"repo_url\" : \"https://gitlab.com/youngestdev1/policies/opal-server\" , \"repo_id\" : 39020791 , ... }","title":"Backend use case"},{"location":"api/#database-operations","text":"GET /data This endpoint retrieves the groupnames stored as part of the usergroups needed in the rego policy creation, it is used to accurately populate the dropdown menu in the frontend. The response will be a list of all the groupnames that have been stored in the database. Example response body: { \"geostore.usergroup\" : [ \"EDITOR_DPAU\" , \"EDITOR_CPQ\" , \"VIEWER\" , \"everyone\" , \"EDITOR_ATAC\" , \"TestGeocity\" , \"EDITOR_AMBIENTE\" , \"GEOCITY_ADMINS\" , \"EDITOR_SIZA\" , \"ROLE_SYS_GWCS\" , \"EDITOR_SITPAU\" , \"EDITOR_DBGT\" , \"ctr-AltimetriaLineeCTRN-VIEW\" , \"ctr-AltimetriaLineeCTRN-EDIT\" , \"EDITOR_NIC\" , \"ambiente-AsparmRaccoltaFarmaci-EDIT\" , \"EDITOR_URBANISTICA\" , \"EDITOR_CITTA_PUBBLICA\" , \"EDITOR_VINCOLI\" , \"EDITOR_COMPLETO\" ] }","title":"Database Operations"},{"location":"architecture/","text":"Architecture Application structure The API is written in Python and FastAPI framework, in a way that it is easy to use, extend, test and maintain. Application components The application is composed of the following components: SERVER : The SERVER is the main component of the application. It is responsible for handling network requests and responses between the application and other components of the application(API component and services). It is also responsible for handling the interaction between the application and other third party APIs such as GitHub, Gitlab, etc. The application uses Github/Gitlab to authenticate users and to get the user's repositories. The application also uses Github/Gitlab to commit and push the changes to the user's repository. Utility Functions : The utility functions are responsible for the logic of the application. They are responsible for handling the conversion from JSON to REGO with command mapping, writing the converted rules into a file, and getting the file ready for commit and push to the user's repository. Schemas : The schemas are responsible for the data validation of the application. They are responsible for validating the data that is sent to the application and the data that is received from the application. They ensure that the JSON is in the correct format and that it is valid, in order to avoid any errors in the REGO conversion. Databases : The application uses two different databases. The first database stores the state of the REGO rules for future CRUD operations, after the initial write. It uses TinyDB to store the state of the rules. The second database is a POSTGRES database. There are times where the authorization rules are dependent on data from a database. For example, a user can only access a resource if they are in a specific group in the database. The API supports the use of databases by providing a datasource command that fetches the structure of the data present in the database and creates a REGO rules that depends on data from the postgres. The SQL query that fetches this group information is below; SELECT DISTINCT groupname AS value FROM geostore . gs_usergroup This query is executed by the API as a string and the API creates rules that depends on its result. result; { \"geostore.usergroup\" : [ \"EDITOR_DPAU\" , \"EDITOR_CPQ\" , \"VIEWER\" , \"everyone\" , \"EDITOR_ATAC\" , \"TestGeocity\" , \"EDITOR_AMBIENTE\" , \"GEOCITY_ADMINS\" , \"EDITOR_SIZA\" , \"ROLE_SYS_GWCS\" , \"EDITOR_SITPAU\" , \"EDITOR_DBGT\" , \"ctr-AltimetriaLineeCTRN-VIEW\" , \"ctr-AltimetriaLineeCTRN-EDIT\" , \"EDITOR_NIC\" , \"ambiente-AsparmRaccoltaFarmaci-EDIT\" , \"EDITOR_URBANISTICA\" , \"EDITOR_CITTA_PUBBLICA\" , \"EDITOR_VINCOLI\" , \"EDITOR_COMPLETO\" ] } An example of rego policy that is dependent on the group information in the postgres database is shown below. The geostore.usergroup is the name of the datasource and the data is the name of the variable that holds the data. To access the data from the database, the schema name + the table name must be prefixed with data. . data.geostore.usergroup = data.schema_name.table_name allow { data.geostore.usergroup[_] == \"EDITOR_DPAU\" } This rule checks if the user in the request belongs to a group called EDITOR_DPAU . If the user belongs to the group, the rule returns true and the user is allowed to access the resource. If the user does not belong to the group, the rule returns false and the user is not allowed to access the resource.","title":"Application architecture overview"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#application-structure","text":"The API is written in Python and FastAPI framework, in a way that it is easy to use, extend, test and maintain.","title":"Application structure"},{"location":"architecture/#application-components","text":"The application is composed of the following components: SERVER : The SERVER is the main component of the application. It is responsible for handling network requests and responses between the application and other components of the application(API component and services). It is also responsible for handling the interaction between the application and other third party APIs such as GitHub, Gitlab, etc. The application uses Github/Gitlab to authenticate users and to get the user's repositories. The application also uses Github/Gitlab to commit and push the changes to the user's repository. Utility Functions : The utility functions are responsible for the logic of the application. They are responsible for handling the conversion from JSON to REGO with command mapping, writing the converted rules into a file, and getting the file ready for commit and push to the user's repository. Schemas : The schemas are responsible for the data validation of the application. They are responsible for validating the data that is sent to the application and the data that is received from the application. They ensure that the JSON is in the correct format and that it is valid, in order to avoid any errors in the REGO conversion. Databases : The application uses two different databases. The first database stores the state of the REGO rules for future CRUD operations, after the initial write. It uses TinyDB to store the state of the rules. The second database is a POSTGRES database. There are times where the authorization rules are dependent on data from a database. For example, a user can only access a resource if they are in a specific group in the database. The API supports the use of databases by providing a datasource command that fetches the structure of the data present in the database and creates a REGO rules that depends on data from the postgres. The SQL query that fetches this group information is below; SELECT DISTINCT groupname AS value FROM geostore . gs_usergroup This query is executed by the API as a string and the API creates rules that depends on its result. result; { \"geostore.usergroup\" : [ \"EDITOR_DPAU\" , \"EDITOR_CPQ\" , \"VIEWER\" , \"everyone\" , \"EDITOR_ATAC\" , \"TestGeocity\" , \"EDITOR_AMBIENTE\" , \"GEOCITY_ADMINS\" , \"EDITOR_SIZA\" , \"ROLE_SYS_GWCS\" , \"EDITOR_SITPAU\" , \"EDITOR_DBGT\" , \"ctr-AltimetriaLineeCTRN-VIEW\" , \"ctr-AltimetriaLineeCTRN-EDIT\" , \"EDITOR_NIC\" , \"ambiente-AsparmRaccoltaFarmaci-EDIT\" , \"EDITOR_URBANISTICA\" , \"EDITOR_CITTA_PUBBLICA\" , \"EDITOR_VINCOLI\" , \"EDITOR_COMPLETO\" ] } An example of rego policy that is dependent on the group information in the postgres database is shown below. The geostore.usergroup is the name of the datasource and the data is the name of the variable that holds the data. To access the data from the database, the schema name + the table name must be prefixed with data. . data.geostore.usergroup = data.schema_name.table_name allow { data.geostore.usergroup[_] == \"EDITOR_DPAU\" } This rule checks if the user in the request belongs to a group called EDITOR_DPAU . If the user belongs to the group, the rule returns true and the user is allowed to access the resource. If the user does not belong to the group, the rule returns false and the user is not allowed to access the resource.","title":"Application components"},{"location":"installation/","text":"- Manual installation Configure your environment variables: # Base path to clone the rego repository to BASE_PATH = /tmp # Path to the directory where the TinyDB database is stored. DATABASE_PATH = /tmp/database.json ORG_NAME = geobeyond/policies # Organization name identifies individual clients on Gitlab. ENVIRONMENT=<your_environment e.g. production|development> # A list of super_users that can access the admin functionality. super_user=[\"<github_username|gitlab_username>\"] # Postgres database configuration to retrieve group names from. DB_USER=geostore PASSWORD=geostore DATABASE=geostore HOST=db PORT=5432 Create a virtual environment and install the application dependencies: $ poetry shell && poetry install Run the application from the entry point: $ python3 main.py Open localhost:8000/docs for API Documentation - Build the application image and start the container Configure environment variables as mentionaed above. Build the image with docker-compose: $ docker-compose -f docker-compose.dev.yml up -d - Pull the official image from Docker Hub and start the container $ docker run geobeyond/policy-manager-api","title":"Installation procedures for the API"},{"location":"installation/#-manual-installation","text":"Configure your environment variables: # Base path to clone the rego repository to BASE_PATH = /tmp # Path to the directory where the TinyDB database is stored. DATABASE_PATH = /tmp/database.json ORG_NAME = geobeyond/policies # Organization name identifies individual clients on Gitlab. ENVIRONMENT=<your_environment e.g. production|development> # A list of super_users that can access the admin functionality. super_user=[\"<github_username|gitlab_username>\"] # Postgres database configuration to retrieve group names from. DB_USER=geostore PASSWORD=geostore DATABASE=geostore HOST=db PORT=5432 Create a virtual environment and install the application dependencies: $ poetry shell && poetry install Run the application from the entry point: $ python3 main.py Open localhost:8000/docs for API Documentation","title":"- Manual installation"},{"location":"installation/#-build-the-application-image-and-start-the-container","text":"Configure environment variables as mentionaed above. Build the image with docker-compose: $ docker-compose -f docker-compose.dev.yml up -d","title":"- Build the application image and start the container"},{"location":"installation/#-pull-the-official-image-from-docker-hub-and-start-the-container","text":"$ docker run geobeyond/policy-manager-api","title":"-  Pull the official image from Docker Hub and start the container"},{"location":"logic/","text":"JSON to REGO conversion Logic The REGO policies are created by a set of functions called commands that serves as the translation logic. Each of these commands is responsible for writing a specific REGO rule to a .rego file. However, the JSON to REGO conversion must follow certain conditions as defined by a pydantic model for effectiveness. The following is how a rule is defined. The Policy object which is the request body, as well as the Rule object is pydantic models. class Policy : name : str rules : List [ List [ Rule ]] Rule Object: class Rule ( BaseModel ): command : str properties : Dict [ str , Union [ str , List [ str ], Dict [ str , Union [ str , List [ str ]]]]] A rule is defined by two keys: command and properties. The command key holds one of the recognized commands and the properties key, holds another dictionary containing the input to the command function e.g input_property and value . in special cases, the datasource_item items are also included in the properties key. { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_method\" , \"value\" : \"GET\" } } In the example above, the command key represents the operation to be performed and the properties key represents the properties that are being used in the operation. input_prop_equals is the command in the example that initiates the appropriate operation, on the properties object. The above rule translates to an equality check between the input property input_property and the value value . The REGO equivalent of the above rule object is: `input.request_method == \"GET\"` Each Rule object forms a specific rule in a Allow block, and a list of Rules forms a Allow block. The API supports the following commands; input_prop_equals, input_prop_in, input_prop_in_as, allow_full_access. input_props_equals Path authorization is the most important feature of the API Allow users the access to all the paths, except a particular path variable. Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"/users/*\" , \"exceptional_value\" : \"payment\" , } } Result: input.request_path[0] = \"users input.request_path[1] != \"payment\" With the above rule, all the request paths, that starts with /users will be allowed, except the payment. Example: /users/feed - returns Authorised /users/posts/comment - returns Authorised /users/payment - returns Unauthorised Allow only access to request path prefixed with /users only Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"/users/*\" , }, } Result: input.request_path[0] = \"users Example: /users/followers - returns Authorised /users/feeds/posts - returns Authorised /payment - returns Unauthorised Allow only users access to their own routes. A log in with the username Habeeb , should have access to request path prefixed with /users/Habeeb and not /users/John Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}/*\" , }, } Result: some username input.request_path[0] = \"users input.request_path[1] = \"username With the above rule, all the request paths, that starts with /users/{username} will be allowed Example: Say the username from an identity provider is habeeb /users/habeeb/profile - returns Authorised /users/habeeb/posts - returns Authorised /users/john/posts - returns Unauthorised These rules targets a specific path. Only a certain path will be allowed, while every other path is rejected. Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"users/payment\" , }, } Result: input.request_path = [\"users\", \"payment\"] or { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"users/{username}\" , }, } Result: some username input.request_path = [\"users\", username] input.preferred_username = username Example: Say the username from an identity provider is habeeb /users/habeeb - returns Authorised /users/habeeb/profile - returns Unauthorised /users/payment - returns Authorised /users/feeds - returns Unauthorised Allow users the access to all the paths prefixed with the username, except a particular path variable. Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"/users/{username}/*\" , \"exceptional_value\" : \"chat\" , } } Result: some username input.preferred_username = username input.request_path[0] = \"users input.request_path[1] = username input.request_path[2] = \"chat\" With the above rule, all the request paths, that starts with /users/{username} will be allowed, except /users/{username}/chat Example: /users/habeeb/feed - returns Authorised /users/habeeb/posts - returns Authorised /users/habeeb/payment - returns Unauthorised Note that a couple of these rules can be combined to achieve your authorization rules, and it is not limited to example given here. input_props_in This logic checks if a particular property on the input object is present in a list of values from the database. Example: { \"command\" : \"input_prop_in\" , \"properties\" : { \"input_property\" : \"groupname\" , \"datasource_name\" : \"usergroups\" , \"datasource_loop_variable\" : \"name\" } } In the json above, the input_property key holds the property that is to be validated before the request to that path is passed. The datasource_name key holds the name of the datasource(a list) from the database. The datasource_loop_variable key holds the name of the key on each object in the datasource. The rego rules combine data from the database with the input object, to work out certain conditions. The datasource is the list of values from the database, and the datasource_loop_variable is the name of the key on each object in the datasource. The REGO equivalent of the above rule object is: input.groupname == data.usergroups[i].name allow_if_object_in_database This logic checks if the value of two properties on the input object is present on one object in the database Example: { \"command\" : \"allow_if_object_in_database\" , \"properties\" : { \"datasource_name\" : \"usergroups\" , \"datasource_variables\" : [ \"name\" , \"groupname\" ], } } In the JSON above, the resulting REGO code loops over the datasource twice, checking for equality between the values of the input properties, and the values of the datasource loop variables. The REGO equivalent of the above rule object is: { name: input.name, groupname: input.groupname} == data.usergroups[_] allow_full_access This logic allows full access to the resources defined. If the value of the property on the input object has a particular value Example: [ { \"command\" : \"allow_full_access\" , \"properties\" : { \"input_property\" : \"groupname\" , \"value\" : \"EDITOR_ATAC\" , }, } ] In the JSON above, the result is an allow block that allows access to the resources defined if the value of the property on the input object has a particular value. allow { input.groupname == \"EDITOR_ATAC\" }","title":"Conversion Logic"},{"location":"logic/#json-to-rego-conversion-logic","text":"The REGO policies are created by a set of functions called commands that serves as the translation logic. Each of these commands is responsible for writing a specific REGO rule to a .rego file. However, the JSON to REGO conversion must follow certain conditions as defined by a pydantic model for effectiveness. The following is how a rule is defined. The Policy object which is the request body, as well as the Rule object is pydantic models. class Policy : name : str rules : List [ List [ Rule ]] Rule Object: class Rule ( BaseModel ): command : str properties : Dict [ str , Union [ str , List [ str ], Dict [ str , Union [ str , List [ str ]]]]] A rule is defined by two keys: command and properties. The command key holds one of the recognized commands and the properties key, holds another dictionary containing the input to the command function e.g input_property and value . in special cases, the datasource_item items are also included in the properties key. { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_method\" , \"value\" : \"GET\" } } In the example above, the command key represents the operation to be performed and the properties key represents the properties that are being used in the operation. input_prop_equals is the command in the example that initiates the appropriate operation, on the properties object. The above rule translates to an equality check between the input property input_property and the value value . The REGO equivalent of the above rule object is: `input.request_method == \"GET\"` Each Rule object forms a specific rule in a Allow block, and a list of Rules forms a Allow block. The API supports the following commands; input_prop_equals, input_prop_in, input_prop_in_as, allow_full_access.","title":"JSON to REGO conversion Logic"},{"location":"logic/#input_props_equals","text":"Path authorization is the most important feature of the API Allow users the access to all the paths, except a particular path variable. Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"/users/*\" , \"exceptional_value\" : \"payment\" , } } Result: input.request_path[0] = \"users input.request_path[1] != \"payment\" With the above rule, all the request paths, that starts with /users will be allowed, except the payment. Example: /users/feed - returns Authorised /users/posts/comment - returns Authorised /users/payment - returns Unauthorised Allow only access to request path prefixed with /users only Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"/users/*\" , }, } Result: input.request_path[0] = \"users Example: /users/followers - returns Authorised /users/feeds/posts - returns Authorised /payment - returns Unauthorised Allow only users access to their own routes. A log in with the username Habeeb , should have access to request path prefixed with /users/Habeeb and not /users/John Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}/*\" , }, } Result: some username input.request_path[0] = \"users input.request_path[1] = \"username With the above rule, all the request paths, that starts with /users/{username} will be allowed Example: Say the username from an identity provider is habeeb /users/habeeb/profile - returns Authorised /users/habeeb/posts - returns Authorised /users/john/posts - returns Unauthorised These rules targets a specific path. Only a certain path will be allowed, while every other path is rejected. Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"users/payment\" , }, } Result: input.request_path = [\"users\", \"payment\"] or { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"users/{username}\" , }, } Result: some username input.request_path = [\"users\", username] input.preferred_username = username Example: Say the username from an identity provider is habeeb /users/habeeb - returns Authorised /users/habeeb/profile - returns Unauthorised /users/payment - returns Authorised /users/feeds - returns Unauthorised Allow users the access to all the paths prefixed with the username, except a particular path variable. Request body: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"/users/{username}/*\" , \"exceptional_value\" : \"chat\" , } } Result: some username input.preferred_username = username input.request_path[0] = \"users input.request_path[1] = username input.request_path[2] = \"chat\" With the above rule, all the request paths, that starts with /users/{username} will be allowed, except /users/{username}/chat Example: /users/habeeb/feed - returns Authorised /users/habeeb/posts - returns Authorised /users/habeeb/payment - returns Unauthorised Note that a couple of these rules can be combined to achieve your authorization rules, and it is not limited to example given here.","title":"input_props_equals"},{"location":"logic/#input_props_in","text":"This logic checks if a particular property on the input object is present in a list of values from the database. Example: { \"command\" : \"input_prop_in\" , \"properties\" : { \"input_property\" : \"groupname\" , \"datasource_name\" : \"usergroups\" , \"datasource_loop_variable\" : \"name\" } } In the json above, the input_property key holds the property that is to be validated before the request to that path is passed. The datasource_name key holds the name of the datasource(a list) from the database. The datasource_loop_variable key holds the name of the key on each object in the datasource. The rego rules combine data from the database with the input object, to work out certain conditions. The datasource is the list of values from the database, and the datasource_loop_variable is the name of the key on each object in the datasource. The REGO equivalent of the above rule object is: input.groupname == data.usergroups[i].name","title":"input_props_in"},{"location":"logic/#allow_if_object_in_database","text":"This logic checks if the value of two properties on the input object is present on one object in the database Example: { \"command\" : \"allow_if_object_in_database\" , \"properties\" : { \"datasource_name\" : \"usergroups\" , \"datasource_variables\" : [ \"name\" , \"groupname\" ], } } In the JSON above, the resulting REGO code loops over the datasource twice, checking for equality between the values of the input properties, and the values of the datasource loop variables. The REGO equivalent of the above rule object is: { name: input.name, groupname: input.groupname} == data.usergroups[_]","title":"allow_if_object_in_database"},{"location":"logic/#allow_full_access","text":"This logic allows full access to the resources defined. If the value of the property on the input object has a particular value Example: [ { \"command\" : \"allow_full_access\" , \"properties\" : { \"input_property\" : \"groupname\" , \"value\" : \"EDITOR_ATAC\" , }, } ] In the JSON above, the result is an allow block that allows access to the resources defined if the value of the property on the input object has a particular value. allow { input.groupname == \"EDITOR_ATAC\" }","title":"allow_full_access"},{"location":"use-case/","text":"Why do we need this? When a user sends a request to an endpoint, He/She is authenticated by an identity provider e.g Keycloak, AWS IAM, or Okta. The identity provider provides the user with an access token that contains information about the user. The access token is then sent to the application and the application verifies the token and extracts the user information. The application simply provides an API to write the most common policy decisions for your application, by Transforming the JSON policy to REGO. The developer can focus on writing the policy and not on the technical details of REGO. The application then uses the user information to decide whether to allow or deny the request. Writing these decisions requires knowledge of REGO policy language, which is a purpose-built declarative policy language that supports Open Policy Agent (OPA). It is used to write authorization policy allowing OPA to make access control decisions.","title":"Why do we need this?"},{"location":"use-case/#why-do-we-need-this","text":"When a user sends a request to an endpoint, He/She is authenticated by an identity provider e.g Keycloak, AWS IAM, or Okta. The identity provider provides the user with an access token that contains information about the user. The access token is then sent to the application and the application verifies the token and extracts the user information. The application simply provides an API to write the most common policy decisions for your application, by Transforming the JSON policy to REGO. The developer can focus on writing the policy and not on the technical details of REGO. The application then uses the user information to decide whether to allow or deny the request. Writing these decisions requires knowledge of REGO policy language, which is a purpose-built declarative policy language that supports Open Policy Agent (OPA). It is used to write authorization policy allowing OPA to make access control decisions.","title":"Why do we need this?"},{"location":"working/","text":"Working principles fastapi-opa is an extension to FastAPI that allows you to add a login flow to your application within minutes using open policy agent and your favourite identity provider. With this extension, you can authenticate your users using your favourite identity provider and then use the user information to make authorization decisions using OPA. To show the power of this extension, we will use the following example, where we use the rego equivalent of the following JSON policy, to authorize user access to some endpoints in an application. JSON request: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}\" , }, } Our API response: package httpapi.authz import input default allow = false allow { some username input.request_path = [\"user\", username] input.preferred_username = username } Consider a simple FastAPI application, that uses Keycloak identity provider and Opa to make authorization decisions. We'll use the example rego result above to show how to use fastapi-opa to add a login flow to your application. The policy decision in policy/auth.rego authorizes the user to access the endpoint if they're logged as the username in the path. Start by cloning the repository and installing the dependencies: git clone https://github.com/r-scheele/test-api.git cd test-api poetry shell && poetry install Start all the services (Keycloak and Opa) using docker-compose: docker-compose up -d Start the application: uvicorn main:app --port 8000 --reload The application is now running on http://localhost:8000. Configure postman for testing the rules Import the already configured postman collection and environment variables to test the application: test-api.postman_collection.json and test-api.postman_environment.json In the login request, open the test tab and paste the following code: var response = JSON . parse ( responseBody ); postman . setEnvironmentVariable ( \"refresh_token\" , response . refresh_token ); postman . setEnvironmentVariable ( \"access_token\" , response . access_token ); postman . setEnvironmentVariable ( \"session_state\" , response . session_state ); Send request to keycloak to get access token POST {{keycloak_server}}/auth/realms/{{realm}}/protocol/openid-connect/token if you're using the test-api.postman_environment.json , keycloak_server and realm is already set. returns - access token Send request to the application test endpoints in the REGO rules. GET /user/habeeb - Accessible response; { \"message\" : \"Hello World from test1\" } GET /user/john - Inaccessible response; { \"message\" : \"Unauthorized\" } GET /user/{username}/test - Inaccessible response; { \"message\" : \"Unauthorized\" }","title":"Working principles"},{"location":"working/#working-principles","text":"fastapi-opa is an extension to FastAPI that allows you to add a login flow to your application within minutes using open policy agent and your favourite identity provider. With this extension, you can authenticate your users using your favourite identity provider and then use the user information to make authorization decisions using OPA. To show the power of this extension, we will use the following example, where we use the rego equivalent of the following JSON policy, to authorize user access to some endpoints in an application. JSON request: { \"command\" : \"input_prop_equals\" , \"properties\" : { \"input_property\" : \"request_path\" , \"value\" : \"v1/collections/{username}\" , }, } Our API response: package httpapi.authz import input default allow = false allow { some username input.request_path = [\"user\", username] input.preferred_username = username } Consider a simple FastAPI application, that uses Keycloak identity provider and Opa to make authorization decisions. We'll use the example rego result above to show how to use fastapi-opa to add a login flow to your application. The policy decision in policy/auth.rego authorizes the user to access the endpoint if they're logged as the username in the path. Start by cloning the repository and installing the dependencies: git clone https://github.com/r-scheele/test-api.git cd test-api poetry shell && poetry install Start all the services (Keycloak and Opa) using docker-compose: docker-compose up -d Start the application: uvicorn main:app --port 8000 --reload The application is now running on http://localhost:8000.","title":"Working principles"},{"location":"working/#configure-postman-for-testing-the-rules","text":"Import the already configured postman collection and environment variables to test the application: test-api.postman_collection.json and test-api.postman_environment.json In the login request, open the test tab and paste the following code: var response = JSON . parse ( responseBody ); postman . setEnvironmentVariable ( \"refresh_token\" , response . refresh_token ); postman . setEnvironmentVariable ( \"access_token\" , response . access_token ); postman . setEnvironmentVariable ( \"session_state\" , response . session_state );","title":"Configure postman for testing the rules"},{"location":"working/#send-request-to-keycloak-to-get-access-token","text":"POST {{keycloak_server}}/auth/realms/{{realm}}/protocol/openid-connect/token if you're using the test-api.postman_environment.json , keycloak_server and realm is already set. returns - access token","title":"Send request to keycloak to get access token"},{"location":"working/#send-request-to-the-application-test-endpoints-in-the-rego-rules","text":"GET /user/habeeb - Accessible response; { \"message\" : \"Hello World from test1\" } GET /user/john - Inaccessible response; { \"message\" : \"Unauthorized\" } GET /user/{username}/test - Inaccessible response; { \"message\" : \"Unauthorized\" }","title":"Send request to the application test endpoints in the REGO rules."}]}